---
---


Q: 컴파일과 링크는 무엇인가요?

A: 컴파일은 C++ 코드를 컴퓨터가 이해하는 기계어(.obj 파일)로 번역하는 과정입니다. 링크는 이 번역된 .obj 파일들을 하나로 묶어 최종 프로그램(.exe, .dll)을 만드는 과정입니다.

Q: 왜 컴파일과 링크가 분리되어 있나요?

A: 빌드 과정을 병렬화하기 위해서입니다. 수많은 .cpp 파일을 동시에 컴파일한 후, 모든 파일이 완성된 후에 한 번에 링킹하여 전체 빌드 시간을 단축합니다.

Q: .h 파일은 컴파일에 꼭 필요한가요?

A: 네, 필수적입니다. .h 파일은 함수와 클래스들의 선언을 담고 있어, 컴파일러가 .cpp 파일을 읽을 때 어떤 요소들이 존재하는지 미리 알 수 있게 해주는 '설계도' 역할을 합니다.

Q: 선언만 있고 구현이 없으면 무슨 오류가 발생하나요?

A: 컴파일 시에는 오류가 나지 않습니다. 하지만 링커가 최종 프로그램을 만들 때 해당 함수의 '구현'을 찾지 못해 링크 에러가 발생합니다.

Q: 링커는 어떻게 구현을 연결하나요?

A: 링커는 .obj 파일 안에 있는 심볼 테이블이라는 색인 정보를 사용합니다. 모든 .obj 파일의 심볼 테이블을 모아 거대한 목록을 만든 후, 필요한 함수와 변수의 주소를 효율적으로 찾아 연결합니다.

Q: `#include` 가 중첩되면 컴파일 시간이 왜 느려지나요?

A: 컴파일러가 `#include` 구문을 만날 때마다 헤더 파일의 내용을 .cpp 파일에 복사-붙여넣기처럼 처리하기 때문입니다. 중첩된 `#include` 가 많아지면 컴파일러가 처리해야 할 코드의 양이 기하급수적으로 늘어납니다.

Q: `#pragma_once` 와 `IWYU(Include What You Use)`의 차이점은 무엇인가요?

A: `#pragma_once` 는 컴파일러가 하나의 컴파일 단위 내에서 한 헤더 파일을 두 번 이상 중복해서 읽는 것을 방지하여 무한 루프와 중복 처리를 막는 기술적인 지시어입니다.

반면, IWYU는 소스 파일이 직접 사용하는 헤더만 포함하도록 권장하는 개발 철학입니다. 
- `.cpp` 파일이 직접 사용하는 클래스나 함수가 정의된 헤더만 포함한다. 
- 헤더 파일은 자신이 정의하는 내용에 필요한 다른 헤더만 포함한다.

이는 불필요한 헤더의 중첩 포함(Header Bloat)을 막아 컴파일러가 처리할 코드의 총량을 줄여줍니다.

Q: PCH(Precompiled Header)의 이점과 단점은 무엇인가요?

A: PCH는 컴파일 시간을 극적으로 단축시키는 효과적인 기술이지만, 몇 가지 단점도 존재합니다.

**이점 (장점):**

- **컴파일 시간 단축:** 프로젝트에서 가장 자주 사용되는 수많은 헤더를 `.cpp` 파일 하나를 준비해 컴파일하여 `.pch` 파일로 저장합니다. - 빌드 시스템은 이 `#include`가 PCH 파일을 사용하는 것임을 인지하고, 전처리기가 헤더 내용을 복사-붙여넣기하는 일반적인 과정을 건너뜁니다. 대신, 컴파일러는 이미 완성된 `*.pch` 파일을 디스크에서 읽어와 메모리에 로드합니다.
- 매번 헤더들을 다시 처리할 필요가 없어 빌드 속도가 매우 빨라집니다.

**단점 (부작용):**

- **빌드 취약성:** PCH에 포함된 헤더 파일 중 하나라도 변경되면, PCH 전체가 다시 컴파일되어야 합니다. 이는 해당 PCH를 사용하는 모든 소스 파일을 다시 빌드하게 만들어, 작은 수정에도 빌드 시간이 매우 길어질 수 있습니다.
- **숨겨진 의존성:** PCH가 수많은 헤더를 미리 포함하기 때문에, 개발자가 필요한 `#include`를 빠뜨려도 컴파일 에러가 발생하지 않는 경우가 많습니다. 이는 코드의 의존성을 불명확하게 만들어, 다른 환경에서 빌드하거나 PCH를 사용하지 않을 때 오류를 일으킬 수 있습니다.
- **높은 리소스 사용량:** `*.pch` 파일 자체의 크기가 매우 커서, 디스크 공간을 많이 차지하고 컴파일 시 메모리 사용량도 높아집니다.


Q: 유니티 빌드는 왜 필요한가요?

A: 유니티 빌드는 여러 개의 작은 `.cpp` 파일들을 하나의 큰 `.cpp` 파일로 합쳐서 컴파일하는 빌드 시스템 최적화 기술입니다.
- **링크 시간 단축:** 100개의 `.cpp` 파일이 10개의 유니티 파일로 합쳐지면, 링커가 처리해야 할 `.obj` 파일의 수가 **10분의 1**로 줄어들어 링크 시간이 획기적으로 단축됩니다.
- **컴파일 시간 단축:** 여러 `.cpp` 파일에서 공통으로 포함하는 헤더 파일들을 **단 한 번만 처리**하게 되므로 컴파일러의 중복 작업이 사라져 컴파일 시간도 줄어듭니다.
언리얼 엔진의 UBT(Unreal Build Tool)가 바로 이 유니티 빌드 기능을 관리합니다.


Q: 언리얼 엔진에서 클래스 추가는 빌드 후 재시작해야 하는데, 코드 수정은 왜 컴파일 버튼만 누르면 되나요?

A: 새로운 클래스를 추가하는 것은 엔진의 기본 구조에 새로운 타입을 선언하는 것이므로, UBT가 리플렉션 메타데이터를 새로 생성해야 합니다. 이는 근본적인 변경이라 엔진이 처음부터 다시 시작해야만 완벽히 인식할 수 있습니다. 반면, 기존 코드 수정은 **라이브 코딩** 기능으로 실행 중에 `.cpp` 파일만 컴파일하여 새로운 DLL로 교체하기 때문에 재시작이 필요 없습니다.

Q: 그렇다면 라이브 코딩은 어떻게 실행 중에 코드를 교체하나요?

A: 라이브 코딩은 변경된 `.cpp` 파일만 백그라운드에서 컴파일하여 새로운 DLL 파일을 만듭니다. 이후, 엔진이 한 프레임이 끝나는 안전한 시점을 기다렸다가, 기존 함수 포인터들을 새로운 DLL에 있는 함수로 리디렉션하여 코드를 교체하는 방식으로 작동합니다.

[[Unreal Source Build]]
[[DDC(Derived Data Cache)]]