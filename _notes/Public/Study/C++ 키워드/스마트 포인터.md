
포인터를 사용할때 마주하는 문제 상황이 있다.
### **1. 선언만 봐서는 객체를 가리키는지 배열을 가리키는지 구분X**

```
int* p1 = new int;      // 단일 정수 객체
int* p2 = new int[10];  // 정수 10개로 이루어진 배열
```

이는 메모리 해제 시 `delete`를 쓸지 `delete[]`를 쓸지 결정하는 데 혼란을 초래합니다.
프로그램 충돌, 메모리 누수, 데이터 손상 등으로 이어질 수 있습니다.
### **2. 선언만 봐서는 포인터가 객체를 소유하고 있는지 여부를 알 수 없다**

```
void processData(MyClass* data) {
    // data를 사용만 해야 할까, 아니면 다 쓰고 delete해야 할까?
    // 이 함수의 선언만으로는 알 수 없다.
}
```

책임 소재가 불분명해집니다.
### **3. 포인터가 가리키는 객체를 어떻게 파괴해야 하는지 알 수 없다**

```
// 외부 라이브러리 함수가 반환하는 포인터
MyObject* createObjectFromLibrary();

MyObject* obj = createObjectFromLibrary();
// 이 객체를 delete해야 할까?
// 아니면 destroyObjectFromLibrary(obj) 같은 함수를 써야 할까?
```
원시 포인터는 이러한 생성/소멸 메커니즘에 대한 정보를 담고 있지 않습니다.

### 4. 코드의 모든 경로에서 파괴가 정확히 한 번 일어남을 보장할 수 없다**

```
void process(int value) {
    MyClass* ptr = new MyClass;

    if (value < 0) {
        return; // 메모리 누수 발생! delete ptr; 가 호출되지 않음
    }

    // ... 다른 로직
    delete ptr;
}
```
예외가 발생하거나, 여러 `return`문이 있는 복잡한 함수에서는 메모리 해제를 빠뜨리기 쉽고
포인터를 실수로 두 번 해제하는 경우가 발생할 수 있습니다.
### **5. 포인터가 가리키는 객체가 파괴되었는지 알 수 없다**
```
MyClass* ptr1 = new MyClass;
MyClass* ptr2 = ptr1;

delete ptr1; // ptr1이 가리키는 메모리 해제

// ptr2는 이제 댕글링 포인터가 됨.
// ptr2를 사용하면 정의되지 않은 동작 발생
ptr2->doSomething();
```

---

이 문제들을 방지 가능한 포인터가 있다.
[[unique_ptr]]