
### 좌측값 (Lvalue)과 우측값 (Rvalue)

- **좌측값 (Lvalue)**: 이름이 있고, 메모리 주소를 가지며, 프로그램의 실행 동안 수명이 보장되는 값입니다. 
- **우측값 (Rvalue)**: 이름이 없고, 임시적이며, 표현식이 끝나는 즉시 사라지는 값입니다. 
### 우측값 참조 (Rvalue Reference)

이동 시맨틱스 구현 핵심 요소

```
#include <memory>
#include <utility>
#include <iostream>

class Refernce
{
    int* P;
public:
    int C;
    Refernce()
        : C(0),P(nullptr)
    {
        std::cout << "기본 생성자 호출" << std::endl;
    }
    Refernce(Refernce&& other) noexcept
        : C(1), P(nullptr)
    {
        std::cout << "이동 생성자 호출" << std::endl;
    }
    Refernce(const Refernce& other)
        : C(2), P(nullptr)
    {
        std::cout << "복사 생성자 호출" << std::endl;
    }
    ~Refernce() { std::cout << "소멸자 호출" << std::endl;}
};

int main()
{
    Refernce&& refer = Refernce();
    Refernce Test1 = Refernce(refer);
    Refernce Test2 = Refernce(static_cast<Refernce&&>(refer));
    return 0;
}
```

#### **결과 해석**

1. `Refernce&& refer = Refernce();`
    
    - `Refernce()`는 이름이 없는 **우측값**입니다.
        
    - `refer`는 이 우측값에 바인딩되어 그 수명을 연장합니다. `기본 생성자`가 호출됩니다.
        
2. `Refernce Test1 = Refernce(refer);`
    
    - `refer`는 우측값 참조 변수이며, **이름이 있는 변수**이므로 **좌측값**으로 간주됩니다.
        
    - `Test1`은 좌측값인 `refer`를 복사하여 생성되므로, `복사 생성자`가 호출됩니다.
        
3. `Refernce Test2 = Refernce(static_cast<Refernce&&>(refer));`
    
    - `static_cast<Refernce&&>(refer)`는 좌측값인 `refer`를 **우측값으로 선언합니다.
        
    - `Test2`는 우측값으로 변환된 `refer`로부터 생성되므로, `이동 생성자`가 호출됩니다.
        

### **최종 정리**

- **복사(Copy)**: `Test1`처럼 좌측값으로부터 객체를 만들면, 모든 데이터가 새로 복제되어 비효율적입니다.
    
- **이동(Move)**: `Test2`처럼 우측값으로부터 객체를 만들면, 불필요한 복사 없이 포인터만 옮겨 자원의 소유권을 이전하므로 훨씬 효율적입니다.
    

우측값 참조는 이처럼 깊은 복사가 필요한 객체에서 복사 생성자 대신 이동 생성자를 호출하여, 성능을 크게 향상시키는 중요한 역할을 합니다.